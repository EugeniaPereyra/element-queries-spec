<pre class=metadata>
Title: Element Queries
Shortname: element-queries
Level: 1
Status: DREAM
URL: https://github.com/tomhodgins/element-queries-spec
Repository: tomhodgins/element-query-spec
Editor: Tommy Hodgins, tomhodgins@gmail.com
Abstract: The goal of this document is to specify a syntax for scoped styles and element queries in a container query style, as well as the related selectors, functions, and units that make scoped styles and element queries versatile and powerful way to write layout-independent responsive conditions for elements in CSS.
Logo: <img src=http://elementqueries.com/eqcss-logo.png style=width:100px;>
</pre>

<h2 id=eqcss-syntax>EQCSS Syntax</h2>

  <pre>
    <dfn data-dfn-type=at-rule id=at-ruledef-element>@element</dfn> = <<scoped-style>>
    <dfn data-dfn-type=type>&lt;scoped-style></dfn> = @element " <<selector-list>> " [ <<condition-list>> ] { <<rule-list>> }
    <dfn data-dfn-type=type>&lt;condition-list></dfn> = [ and ( <<eq-condition>> )* ]
    <dfn data-dfn-type=type>&lt;eq-condition></dfn> = <<eq-name>> : <<eq-value>>
    <dfn data-dfn-type=type>&lt;eq-name></dfn> = <<ident>>
    <dfn data-dfn-type=type>&lt;eq-value></dfn> = <<number>> | <<dimension>> | <<ratio>> | <<ident>>
    <dfn data-dfn-type=at-rule id=at-ruledef-meta-selectors>meta-selectors</dfn> = $this | $parent | $prev | $next | $it
    <dfn data-dfn-type=at-rule id=at-ruledef-units>element-based-units</dfn> = ew | eh | emin | emax
  </pre>

<h2 id=style-scoping>Style Scoping</h2>

  <h3 id=scoped-styles>Scoped Styles</h3>

    By default all CSS is written from the global scope ('':root'', or the HTML element), and ''@media'' queries apply based on the conditions of the browser and media.

    The idea of style scoping is to allow CSS to view a rule, or multiple rules from the perspective of any element in the document as thought it was '':root''

    Just like CSS has ''@media'' queries which help us define styles for different media, this document describes functionality for an ''@element'' query syntax to allow us to write styles that target elements more specifically based on their own properties.

    To write a scoped style, write ''@element'', followed by any amount of whitespace. Wrap one or more comma-separated CSS <<selector>> in single (<code>'</code>) or double (<code>"</code>) quotes, followed by any amount of whitespace, and wrap one or more CSS rules in a pair of curly brackets (<code>{</code>,<code>}</code>).

    <div class=example>
      Example Scoped Style</strong>
      <pre class=language-css>
        @element 'html' {
          
        }
      </pre>
    </div>

    <h4 id=multiple-selectors>Multiple Selectors</h4>

      You can include multiple CSS selectors in your scoped style by separating them with a comma and any amount of whitespace.

      <div class=example>
        Comma-separated Selector List
        <pre class=language-css>
          @element 'ul, ol' {
            
          }
        </pre>
      </div>

  <h3 id=element-queries>Element Queries</h3>

    The following global CSS and scoped style are equivalent.

    <div class=example>
      Example of Global CSS
      <pre class=language-css>
        body {
          background: lime;
        }
      </pre>
    </div>

    <div class=example>
      Example Scoped Style
      <pre class=language-css>
        @element 'html' {
          body {
            background: lime;
          }
        }
      </pre>
    </div>

    In both cases, as long as there is a <code>body</code> element inside of our <code>html</code>, it will have a lime background.

    We can also add a responsive conditions to our scoped styles. To do this, write <code>and </code> followed by a responsive condition and value, separated by a colon (<code>:</code>) and wrapped in brackets (<code>(</code>,<code>)</code>).

    <div class=example>
      Example Element Query with Responsive Condition
      <pre class=language-css>
        @element 'html' and (min-width: 500px) {
          body {
            background: lime;
          }
        }
      </pre>
    </div>

    In this case, our element query is equivalent to the following media query, but not every element query will be able to be expressed as a media query.

    <div class=example>
      Example Media Query with Responsive Condition
      <pre class=language-css>
        @media (min-width: 500px) {
          body {
            background: lime;
          }
        }
      </pre>
    </div>

    <h4 id=multiple-conditions>Multiple Conditions</h4>

      You can add more than one responsive conditions to your element query. For this, include another <code>and</code>, followed by another responsive condition as before.

      <div class=example>
        Element Query with Multiple Responsive Conditions
        <pre class=language-css>
          @element 'html' and (min-width: 500px) and (max-width: 1000px) {
            body {
              background: lime;
            }
          }
        </pre>
      </div>

      Which in this case can be compared to the equivalent media query.

      <div class=example>
        Media Query with Multiple Responsive Conditions
        <pre class=language-css>
          @media (min-width: 500px) and (max-width: 1000px) {
            body {
              background: lime;
            }
          }
        </pre>
      </div>

      In both cases when our <code>html</code> is between the sizes of <code>500px</code> and <code>1000px</code>, our <code>body</code> will have a lime background.

    <h4 id=combining-element-and-media-queries>Combining ''@element'' and ''@media'' queries</h4>

      It's possible to combine the use of scoped styles or element queries with media queries. Most of the time we combine them we want to include the media query on the inside of the element query. This will mean any time the element query is true, that media query will be visible to the browser and apply.

      <div class=example>
        Nesting a Media Query inside an Element Query
        <pre class=language-css>
          @element '#headline' and (min-characters: 20) {
            @media print {
              #headline {
                border: 1px solid black;
              }
            }
          }
        </pre>
      </div>

      In this example, if the element with an ID of <code>#headline</code> has over 20 characters, it will display in print media with a thin black border.

    <h4 id=self-referential-element-queries>Self-Referential ''@element'' queries</h4>

      With element queries comes the new possibility that the rules you are applying when your responsive conditions are met will conflict with the responsive condition in your element query. In this situation we should not attempt to detect or handle these cases by ignoring certain styles, or checking whether any of the rules affect the validity of the responsive condition. It is best to apply the rule naïvely and allow the conflict to occur.
    
      Note, The responsibility lies with the author to write ''@element'' queries which can be interpreted logically.

      <div class=example>
        <pre class=language-css>
          @element '.widget' and (min‐width: 300px) {
            $this {
              width: 200px;
            }
          }
        </pre>
      </div>

      In this example the query will only apply to elements with a class of <code>.widget</code> that are equal or wider than <code>300px</code>, and the rule sets a width on the same element which would make the rule no longer apply. Rather than trying to detect or intercept this behaviour and prevent it from happening, when the ''@element'' query applies to the document it will set the width to <code>200px</code>.

    <h4 id=circular-referential-element-queries>Circular Referential ''@element'' queries</h4>

      Another new possibility with element queries is having two or more queries that apply styles that match each others responsive condition. Just as with a self-referential ''@element'' query, we should not try to detect or ignore styles in this situation, and instead should compute the ''@element'' queries in the order they appear and apply the rules using normal CSS specificity.

      <div class=example>
        <pre class=language-css>
          @element '.widget' and (min‐width: 400px) {
            $this {
              width: 200px;
            }
          }
          @element '.widget' and (max‐width: 300px) {
            $this {
              width: 500px;
            }
          }
        </pre>
      </div>

      In this example any element with a class of <code>.widget</code> that is equal to <code>400px</code> or wider will apply a rule setting the width of the same element to <code>200px</code>, which makes the following ''@element'' query valid. The second query sets a width of <code>500px</code> on the same element. In this case, even though the element now matches the responsive condition of the first query again, rather than get stuck in an infinite loop, we consider evaluation complete.

<h2 id=meta-selectors>Meta-Selectors</h2>

  With element queries comes the need to target elements based on the scope we have defined. There are a number of new selectors that help target elements relative to the scope we have defined. These new selectors only work inside a scoped style or element query and are called ''meta-selectors''.

  <h3 id=diagram-of-meta-selectors>Diagram of ''meta-selectors''</h4>

  Here is a diagram showing the relationship between the meta-selectors. The <a class="property" data-link-type="propdesc" data-lt="$parent" for=meta-selectors>$parent</a> is the parent element of <a class="property" data-link-type="propdesc" data-lt="$this" for=meta-selectors>$this</a>, and <a class="property" data-link-type="propdesc" data-lt="$prev" for=meta-selectors>$prev</a> and <a class="property" data-link-type="propdesc" data-lt="$next" for=meta-selectors>$next</a> represent the adjacent siblings to <a class="property" data-link-type="propdesc" data-lt="$this" for=meta-selectors>$this</a>.

  <pre style=text-align:center;>
    <a class="property" data-link-type="propdesc" data-lt="$parent" for=meta-selectors>$parent</a>
    ↑
    <a class="property" data-link-type="propdesc" data-lt="$prev" for=meta-selectors>$prev</a> ← <a class="property" data-link-type="propdesc" data-lt="$this" for=meta-selectors>$this</a> → <a class="property" data-link-type="propdesc" data-lt="$next" for=meta-selectors>$next</a>
  </pre>

  <h3 id=this-selector><code>$this</code> selector</h3>

    <pre class=descdef>
      Name: $this
      For: meta-selectors
      Value: $this | eq_this
      Type: selector
    </pre>

    The <a class="property" data-link-type="propdesc" data-lt="$this" for=meta-selectors>$this</a> meta-selector refers each element at the root of our scoped style when it matches the responsive condition.

    <div class=example>
      Example of <a class="property" data-link-type="propdesc" data-lt="$this" for=meta-selectors>$this</a> meta-selector
      <pre class=language-css>
        @element '.widget' and (min-width: 200px) {
          $this {
            background: lime;
          }
        }
      </pre>
    </div>

    In this case, any element with a class of <code>.widget</code> that is <code>200px</code> or wider will have a green background.

  <h3 id=parent-selector><code>$parent</code> selector</h3>

    <pre class=descdef>
      Name: $parent
      For: meta-selectors
      Value: $parent | eq_parent
      Type: selector
    </pre>

    The <a class="property" data-link-type="propdesc" data-lt="$parent" for=meta-selectors>$parent</a> meta-selector refers to the element containing the element(s) in the scope of our scoped style or element query.

    <div class=example>
      Example of <a class="property" data-link-type="propdesc" data-lt="$parent" for=meta-selectors>$parent</a> meta-selector
      <pre class=language-css>
        @element '.widget' and (min-width: 200px) {
          $parent {
            background: lime;
          }
        }
      </pre>
    </div>

    In this case, any element containing an element with a class of <code>.widget</code> that is equal or wider than <code>200px</code> will have a green background.

  <h3 id=prev-selector><code>$prev</code> selector</h3>

    <pre class=descdef>
      Name: $prev
      For: meta-selectors
      Value: $prev | eq_prev
      Type: selector
    </pre>

    The <a class="property" data-link-type="propdesc" data-lt="$prev" for=meta-selectors>$prev</a> meta-selector refers to the sibling directly above the element at the root of our scoped style or element query.

    <div class=example>
      Example of <a class="property" data-link-type="propdesc" data-lt="$prev" for=meta-selectors>$prev</a> meta-selector
      <pre class=language-css>
        @element '.widget' {
          $prev {
            background: lime;
          }
        }
      </pre>
    </div>

    In this case, any sibling coming directly before any element with a class of <code>.widget</code> will have a green background.

  <h3 id=next-selector><code>$next</code> selector</h3>

    <pre class=descdef>
      Name: $next
      For: meta-selectors
      Value: $next | eq_next
      Type: selector
    </pre>

    The <a class="property" data-link-type="propdesc" data-lt="$next" for=meta-selectors>$next</a> meta-selector refers to the sibling directly below the element at the root of our scoped style or element query.

    <div class=example>
      Example of <a class="property" data-link-type="propdesc" data-lt="$next" for=meta-selectors>$next</a> meta-selector
      <pre class=language-css>
        @element '.widget' {
          $next {
            background: lime;
          }
        }
      </pre>
    </div>

    In this case, any sibling coming directly after any element with a class of <code>.widget</code> will have a green background.
    
    Note, the <a class="property" data-link-type="propdesc" data-lt="$next" for=meta-selectors>$next</a> is similar to the selector: <code>$this + *</code>

<h2 id=responsive-conditions>Responsive Conditions</h2>

  <h3 id=min-width>Min-width</h3>

    <pre class=descdef>
      Name: min-width
      Value: <<dimension>>
      For: @element
      Type: range
    </pre>

    The <a class="property" data-link-type="propdesc" data-lt="min-width" for=@element>min-width</a> responsive condition applies to any scoped element that has greater or equal (<code>>=</code>) width to the specified value.

    <div class=example>
      Example <a class="property" data-link-type="propdesc" data-lt="min-width" for=@element>min-width</a> Element Query
      <pre class=language-css>
        @element '.widget' and (min-width: 200px) {
          $this {
            background: lime;
          }
        }
      </pre>
    </div>

    In this case any element with a class of <code>.widget</code> that is at least <code>200px</code> or wider will have a green background.

  <h3 id=max-width>Max-width</h3>

    <pre class=descdef>
      Name: max-width
      Value: <<dimension>>
      For: @element
      Type: range
    </pre>

    The <a class="property" data-link-type="propdesc" data-lt="max-width" for=@element>max-width</a> responsive condition applies to any scoped element that has lesser or equal (<code><=</code>) width to the specified value.

    <div class=example>
      Example <a class="property" data-link-type="propdesc" data-lt="max-width" for=@element>max-width</a> Element Query
      <pre class=language-css>
        @element '.widget' and (max-width: 200) {
          $this {
            background: lime;
          }
        }
      </pre>
    </div>

    In this case any element with a class of <code>.widget</code> that <code>200px</code> or narrower will have a green background.

  <h3 id=min-height>Min-height</h3>

    <pre class=descdef>
      Name: min-height
      Value: <<dimension>>
      For: @element
      Type: range
    </pre>

    The <a class="property" data-link-type="propdesc" data-lt="min-height" for=@element>min-height</a> responsive condition applies to any scoped element that has greater or equal (<code>>=</code>) height to the specified value.

    <div class=example>
      Example <a class="property" data-link-type="propdesc" data-lt="min-height" for=@element>min-height</a> Element Query
      <pre class=language-css>
        @element '.widget' and (min-height: 50px) {
          $this {
            background: lime;
          }
        }
      </pre>
    </div>

    In this case any element with a class of <code>.widget</code> that is at least <code>50px</code> or taller will have a green background.

  <h3 id=max-height>Max-height</h3>

    <pre class=descdef>
      Name: max-height
      Value: <<dimension>>
      For: @element
      Type: range
    </pre>

    The <a class="property" data-link-type="propdesc" data-lt="max-height" for=@element>max-height</a> responsive condition applies to any scoped element that has lesser or equal (<code><=</code>) height to the specified value.

    <div class=example>
      Example <a class="property" data-link-type="propdesc" data-lt="max-height" for=@element>max-height</a> Element Query
      <pre class=language-css>
        @element '.widget' and (min-height: 50px) {
          $this {
            background: lime;
          }
        }
      </pre>
    </div>

    In this case any element with a class of <code>.widget</code> that is at least <code>50px</code> or shorter will have a green background.

  <h3 id=min-characters>Min-characters</h3>

    <pre class=descdef>
      Name: min-characters
      Value: <<number>>
      For: @element
      Type: range
    </pre>

    The <a class="property" data-link-type="propdesc" data-lt="min-characters" for=@element>min-characters</a> responsive condition applies to any scoped element that contains a greater or equal (<code>>=</code>) number of characters.

    <div class=example>
      Example <a class="property" data-link-type="propdesc" data-lt="min-characters" for=@element>min-characters</a> Element Query
      <pre class=language-css>
        @element 'input' and (min-characters: 5) {
          $this {
            background: lime;
          }
        }
      </pre>
    </div>

    In this case any input with 5 or more characters will have a green background.

  <h3 id=max-characters>Max-characters</h3>

    <pre class=descdef>
      Name: max-characters
      Value: <<number>>
      For: @element
      Type: range
    </pre>

    The <a class="property" data-link-type="propdesc" data-lt="max-characters" for=@element>max-characters</a> responsive condition applies to any scoped element that contains lesser or equal (<code><=</code>) number of characters specified.

    <div class=example>
      Example <a class="property" data-link-type="propdesc" data-lt="max-characters" for=@element>max-characters</a> Element Query
      <pre class=language-css>
        @element 'input' and (max-characters: 5) {
          $this {
            background: lime;
          }
        }
      </pre>
    </div>

    In this case any input with 5 or fewer characters will have a green background.

  <h3 id=min-lines>Min-lines</h3>

    <pre class=descdef>
      Name: min-lines
      Value: <<number>>
      For: @element
      Type: range
    </pre>

    The <a class="property" data-link-type="propdesc" data-lt="min-lines" for=@element>min-lines</a> responsive condition applies to any scoped element that contains greater or equal (<code>>=</code>) number of specified lines of text.

    <div class=example>
      Example <a class="property" data-link-type="propdesc" data-lt="min-lines" for=@element>min-lines</a> Element Query
      <pre class=language-css>
        @element 'textarea' and (min-lines: 3) {
          $this {
            background: lime;
          }
        }
      </pre>
    </div>

    In this case any textarea with 3 or more lines will have a green background.

  <h3 id=max-lines>Max-lines</h3>

    <pre class=descdef>
      Name: max-lines
      Value: <<number>>
      For: @element
      Type: range
    </pre>

    The <a class="property" data-link-type="propdesc" data-lt="max-lines" for=@element>max-lines</a> responsive condition applies to any scoped element that contains lesser or equal (<code><=</code>) number of specified lines of text.

    <div class=example>
      Example <a class="property" data-link-type="propdesc" data-lt="max-lines" for=@element>max-lines</a> Element Query
      <pre class=language-css>
        @element 'textarea' and (max-lines: 3) {
          $this {
            background: lime;
          }
        }
      </pre>
    </div>

    In this case any textarea with 3 or fewer lines will have a green background.

  <h3 id=min-children>Min-children</h3>

    <pre class=descdef>
      Name: min-children
      Value: <<number>>
      For: @element
      Type: range
    </pre>

    The <a class="property" data-link-type="propdesc" data-lt="min-children" for=@element>min-children</a> responsive condition applies to any scoped element that contains greater or equal (<code>>=</code>) number of child elements specified.

    <div class=example>
      Example <a class="property" data-link-type="propdesc" data-lt="min-children" for=@element>min-children</a> Element Query
      <pre class=language-css>
        @element '.social-icons' and (min-children: 5) {
          $this {
            background: lime;
          }
        }
      </pre>
    </div>

    In this case any element with a class of <code>.social-icons</code> that contains more 5 or more direct descendants will have a green background.

  <h3 id=max-children>Max-children</h3>

    <pre class=descdef>
      Name: max-children
      Value: <<number>>
      For: @element
      Type: range
    </pre>

    The <a class="property" data-link-type="propdesc" data-lt="max-children" for=@element>max-children</a> responsive condition applies to any scoped element that contains lesser or equal (<code><=</code>) number of child elements specified.

    <div class=example>
      Example <a class="property" data-link-type="propdesc" data-lt="max-children" for=@element>max-children</a> Element Query
      <pre class=language-css>
        @element '.social-icons' and (max-children: 5) {
          $this {
            background: lime;
          }
        }
      </pre>
    </div>

    In this case any element with a class of <code>.social-icons</code> that contains more 5 or fewer direct descendants will have a green background.

  <h3 id=min-scroll-y>Min-scroll-y</h3>

  <pre class=descdef>
    Name: min-scroll-y
    Value: <<dimension>>
    For: @element
    Type: range
  </pre>

    The <a class="property" data-link-type="propdesc" data-lt="min-scroll-y" for=@element>min-scroll-y</a> responsive condition applies to any scoped element that has scrolled a greater or equal (<code>>=</code>) amount to the value specified in a vertical direction.

    <div class=example>
      Example <a class="property" data-link-type="propdesc" data-lt="min-scroll-y" for=@element>min-scroll-y</a> Element Query
      <pre class=language-css>
        @element '.feed' and (min-scroll-y: 100px) {
          $this {
            background: lime;
          }
        }
      </pre>
    </div>

    In this case any element with a class of <code>.feed</code> that has scrolled  <code>100px</code> or more vertical will have a green background.

  <h3 id=max-scroll-y>Max-scroll-y</h3>

    <pre class=descdef>
      Name: max-scroll-y
      Value: <<dimension>>
      For: @element
      Type: range
    </pre>

    The <a class="property" data-link-type="propdesc" data-lt="max-scroll-y" for=@element>max-scroll-y</a> responsive condition applies to any scoped element that has scrolled a lesser or equal (<code><=</code>) amount to the value specified in a vertical direction.

    <div class=example>
      Example <a class="property" data-link-type="propdesc" data-lt="max-scroll-y" for=@element>max-scroll-y</a> Element Query
      <pre class=language-css>
        @element '.feed' and (max-scroll-y: 100px) {
          $this {
            background: lime;
          }
        }
      </pre>
    </div>

    In this case any element with a class of <code>.feed</code> that has scrolled  <code>100px</code> or less vertically will have a green background.

  <h3 id=min-scroll-x>Min-scroll-x</h3>

    <pre class=descdef>
      Name: min-scroll-x
      Value: <<dimension>>
      For: @element
      Type: range
    </pre>

    The <a class="property" data-link-type="propdesc" data-lt="min-scroll-x" for=@element>min-scroll-x</a> responsive condition applies to any scoped element that has scrolled a greater or equal (<code>>=</code>) amount to the value specified in a horizontal direction.

    <div class=example>
      Example <a class="property" data-link-type="propdesc" data-lt="min-scroll-x" for=@element>min-scroll-x</a> Element Query
      <pre class=language-css>
        @element '.feed' and (min-scroll-x: 100px) {
          $this {
            background: lime;
          }
        }
      </pre>
    </div>

    In this case any element with a class of <code>.feed</code> that has scrolled  <code>100px</code> or more horizontally will have a green background.

  <h3 id=max-scroll-x>Max-scroll-x</h3>

    <pre class=descdef>
      Name: max-scroll-x
      Value: <<dimension>>
      For: @element
      Type: range
    </pre>

    The <a class="property" data-link-type="propdesc" data-lt="max-scroll-x" for=@element>max-scroll-x</a> responsive condition applies to any scoped element that has scrolled a lesser or equal (<code><=</code>) amount to the value specified in a horizontal direction.

    <div class=example>
      Example <a class="property" data-link-type="propdesc" data-lt="max-scroll-x" for=@element>max-scroll-x</a> Element Query
      <pre class=language-css>
        @element '.feed' and (max-scroll-x: 100px) {
          $this {
            background: lime;
          }
        }
      </pre>
    </div>

    In this case any element with a class of <code>.feed</code> that has scrolled  <code>100px</code> or less horizontally will have a green background.

  <h3 id=orientation>Orientation</h3>

    <pre class=descdef>
      Name: orientation
      Value: portrait | square | landscape
      For: @element
      Type: discrete
    </pre>

    The 'orientation' responsive condition applies to any scoped element that matches the orientation specified. The following orientations are included: ''landscape'', <a class="css" data-link-type="maybe" data-lt="square" for=@element/orientation>square</a>, ''portrait''

    <h4 id=portrait-orientation>Portrait Orientation</h4>

      <dl dfn-type=value dfn-for=@element/orientation>
        <dt><dfn>portrait</dfn>
        <dd>The 'orientation' is ''portrait'' if the scoped element has a greater (<code>></code>) height than width
      </dl>

      <div class=example>
        Element Query for ''portrait'' Orientation</strong>
        <pre class=language-css>
          @element '.widget' and (orientation: portrait) {
            $this {
              background: lime;
            }
          }
        </pre>
      </div>

      In this case any element with a class of <code>.widget</code> that is narrower than it is tall will have a green background.

    <h4 id=square-orientation>Square Orientation</h4>

      <dl dfn-type=value dfn-for=@element/orientation>
        <dt><dfn>square</dfn>
        <dd>The 'orientation' is <a class="css" data-link-type="maybe" data-lt="square" for=@element/orientation>square</a> if the scoped element has an equal (<code>=</code>) height and width
      </dl>

      <div class=example>
        Element Query for <a class="css" data-link-type="maybe" data-lt="square" for=@element/orientation>square</a> Orientation</strong>
        <pre class=language-css>
          @element '.widget' and (orientation: square) {
            $this {
              background: lime;
            }
          }
        </pre>
      </div>

      In this case any element with a class of <code>.widget</code> that has an equal width and height will have a green background.

    <h4 id=landscape-orientation>Landscape Orientation</h4>

      <dl dfn-type=value dfn-for=@element/orientation>
        <dt><dfn>landscape</dfn>
        <dd>The 'orientation' is ''landscape'' if the scoped element has a greater (<code>></code>) width than height
      </dl>

      <div class=example>
        Element Query for ''landscape'' Orientation</strong>
        <pre class=language-css>
          @element '.widget' and (orientation: landscape) {
            $this {
              background: lime;
            }
          }
        </pre>
      </div>

      In this case any element with a class of <code>.widget</code> that is wider than it is tall will have a green background.

  <h3 id=min-aspect-ratio>Min-aspect-ratio</h3>

    <pre class=descdef>
      Name: min-aspect-ratio
      Value: <<ratio>>
      For: @element
      Type: range
    </pre>

    The <a class="property" data-link-type="propdesc" data-lt="min-aspect-ratio" for=@element>min-aspect-ratio</a> responsive condition applies to any scoped element with a greater or equal (<code>>=</code>) aspect ratio, specified as a <code>width</code> and <code>height</code> pair, separated by a slash (<code>/</code>).

    <div class=example>
      Example <a class="property" data-link-type="propdesc" data-lt="min-aspect-ratio" for=@element>min-aspect-ratio</a> Element Query
      <pre class=language-css>
        @element '.widget' and (min-aspect-ratio: 16/9) {
          $this {
            background: lime;
          }
        }
      </pre>
    </div>

    In this case any element that had an aspect ratio of <code>16/9</code> or greater would have a green background.

  <h3 id=max-aspect-ratio>Max-aspect-ratio</h3>

    <pre class=descdef>
      Name: max-aspect-ratio
      Value: <<ratio>>
      For: @element
      Type: range
    </pre>

    The <a class="property" data-link-type="propdesc" data-lt="max-aspect-ratio" for=@element>max-aspect-ratio</a> responsive condition applies to any scoped element with a lesser or equal (<code><=</code>) aspect ratio, specified as a <code>width</code> and <code>height</code> pair, separated by a slash (<code>/</code>).

    <div class=example>
      Example <a class="property" data-link-type="propdesc" data-lt="max-aspect-ratio" for=@element>max-aspect-ratio</a> Element Query
      <pre class=language-css>
        @element '.widget' and (max-aspect-ratio: 16/9) {
          $this {
            background: lime;
          }
        }
      </pre>
    </div>

    In this case any element that had an aspect ratio of <code>16/9</code> or lesser would have a green background.

<h2 id=css-functions>CSS Functions</h2>

  <h3 id=eval>eval("")</h3>
  <pre class=descdef>
    Name: eval("")
    For: @element
    Value: javascript
  </pre>

    Note, Much of the functionality of this feature is similar to CSS variables, however being able to execute JavaScript from the vantage point of the element in the scope could perhaps be a way that CSS variables could be used a little different inside scoped styles or element queries.

    The <a class="property" data-link-type="propdesc" data-lt='eval("")'>eval("")</a> function can be used anywhere inside a scoped style or element query. It shares a scope with the element in the root of the scoped style.

    When using <a class="property" data-link-type="propdesc" data-lt='eval("")'>eval("")</a> you can write <code>eval</code>, followed by a pair of brackets (<code>(</code>,<code>)</code>) which contain JavaScript code, wrapped in either single (<code>'</code>) or double (<code>"</code>) quotes.

    This JavaScript can do something simple like reference the value of a variable, perform a simple calculation inline, or it can use the value return by a function.

    <div class=example>
      Accessing a JavaScript Variable with <a class="property" data-link-type="propdesc" data-lt='eval("")'>eval("")</a></strong>
      <pre class=language-html>
        &lt;script>
          var brandColor = 'lime'
        &lt;/script>

        &lt;style>
          @element '.widget' {
            $this {
              background: eval("brandColor");
            }
          }
        &lt;/style>
      </pre>
    </div>

    In this case any element with a class of <code>.widget</code> will have a green background.

    <div class=example>
      Evaluating JavaScript Inline with <a class="property" data-link-type="propdesc" data-lt='eval("")'>eval("")</a>
      <pre class=language-css>
        @element '.widget' {
          font-size: eval("10 * 2")px;
        }
      </pre>
    </div>

    In this case our inline JavaScript (<code>10 * 2</code>) evaluates in place, leaving us with a font size of <code>20px</code>.

    <div class=example>
      Using Values Returned from Functions with <a class="property" data-link-type="propdesc" data-lt='eval("")'>eval("")</a></strong>
      <pre class=language-html>
        &lt;script>
          function addTen(number){
            var number = parseInt(number) || 0
            return number + 10
          }
        &lt;/script>

        &lt;style>
          @element '.widget' {
            font-size: eval("addTen(15)")px;
          }
        &lt;/style>
      </pre>
    </div>

    In this case any element with a class of <code>.widget</code> will have a font size of <code>25px</code>.

    <h4 id=it-selector><code>$it</code> selector</h4>

      <pre class=descdef>
        Name: $it
        For: meta-selectors
        Value: $it | eq_it
        Type: selector
      </pre>

      By default the inline evaluation of <a class="property" data-link-type="propdesc" data-lt='eval("")'>eval("")</a> shares the same scope in JavaScript as the scoped element. This means for a scoped style like <code>@element '.icon' {}</code>, the following code will select the parent element of the scoped element.

      <div class=example>
        Example of ''eval("")'' with Implicit Context
        <pre class=language-css>
          @element '.widget' {
            $this:before {
              content: 'eval("parentNode.children.length")';
            }
          }
        </pre>
      </div>

      In this case the pseudo-element <code>:before</code> the content of any element with a class of <code>.widget</code> will contain text of the number of child elements inside the parent element of our <code>.widget</code> element.

      The meta-selector <a class="property" data-link-type="propdesc" data-lt="$it" for=meta-selectors>$it</a> works inside <a class="property" data-link-type="propdesc" data-lt='eval("")'>eval("")</a> as a placeholder for the scoped style. The following example is functionally equivalent to the last example.

      <div class=example>
        Example of <a class="property" data-link-type="propdesc" data-lt='eval("")'>eval("")</a> with the <a class="property" data-link-type="propdesc" data-lt="$it" for=meta-selectors>$it</a> Selector
        <pre class=language-css>
          @element '.widget' {
            $this:before {
              content: 'eval("$it.parentNode.children.length")';
            }
          }
        </pre>
      </div>

<h2 id=element-based-units>Element-based Units</h2>

  Just as CSS has viewport-based units: ''vw'', ''vh'', ''vmin'', and ''vmax'' which represent a distance equal to 1/100th of the viewport width, height, shortest edge, and longest edge. In a similar way the following element-based units 'ew', 'eh', 'emin', and 'emax' represent a distance equal to 1/100th of the element's own width, height, shortest edge, and longest edge.

  <h3 id=ew-units>EW units</h3>

    <pre class=descdef>
      Name: ew
      Value: <<number>> ew
      For: element-based-units
      Type: unit
    </pre>

    The 'ew' unit is equal to 1/100th of the width of any scoped element and is able to be used anywhere inside a scoped style.

    <div class=example>
      Example of 'ew' Units Inside a Scoped Style
      <pre class=language-css>
        @element '.widget' {
          $this {
            font-size: 10ew;
          }
        }
      </pre>
    </div>

    In this case the font size of any element with a class of <code>.widget</code> is equal to 10/100 of the scoped element's width.

    Note, This unit is similar to the ''vw'' viewport unit, but based on an element's dimensions.

  <h3 id=eh-units>EH units</h3>

    <pre class=descdef>
      Name: eh
      Value: <<number>> eh
      For: element-based-units
      Type: unit
    </pre>

    The 'eh' unit is equal to 1/100th of the height of any scoped element and is able to be used anywhere inside a scoped style.

    <div class=example>
      Example of 'eh' Units Inside a Scoped Style
      <pre class=language-css>
        @element '.widget' {
          $this {
            font-size: 10eh;
          }
        }
      </pre>
    </div>

    In this case the font size of any element with a class of <code>.widget</code> is equal to 10/100 of the scoped element's height.

    Note, This unit is similar to the ''vh'' viewport unit, but based on an element's dimensions.

  <h3 id=emin-units>EMIN units</h3>

    <pre class=descdef>
      Name: emin
      Value: <<number>> emin
      For: element-based-units
      Type: unit
    </pre>

    The 'emin' unit is equal to 1/100th of the smallest dimension (width or height) of any scoped element and is able to be used anywhere inside a scoped style.

    <div class=example>
      Example of 'emin' Units Inside a Scoped Style
      <pre class=language-css>
        @element '.widget' {
          $this {
            font-size: 10emin;
          }
        }
      </pre>
    </div>

    In this case the font size of any element with a class of <code>.widget</code> is equal to 10/100 of the scoped element's shortest edge.

    Note, This unit is similar to the ''vmin'' viewport unit, but based on an element's dimensions.

  <h3 id=emax-units>EMAX units</h3>

    <pre class=descdef>
      Name: emax
      Value: <<number>> emax
      For: element-based-units
      Type: unit
    </pre>

    The 'emax' unit is equal to 1/100th of the largest dimension (width or height) of any scoped element and is able to be used anywhere inside a scoped style.

    <div class=example>
      Example of 'emax' Units Inside a Scoped Style
      <pre class=language-css>
        @element '.widget' {
          $this {
            font-size: 10emax;
          }
        }
      </pre>
    </div>

    In this case the font size of any element with a class of <code>.widget</code> is equal to 10/100 of the scoped element's longest edge.

    Note, This unit is similar to the ''vmax'' viewport unit, but based on an element's dimensions.

<h2 id=examples-of-element-queries>Examples of Scoped Styles & Element Queries</h2>

<h3 id=wrapper-free-responsive-iframe>Wrapper-free responsive iframe resize</h3>

  <div class=example>
    <pre class=language-html>
      &lt;iframe width="640" height="360">&lt;/iframe>
      &lt;style>
        @element 'iframe' {
          $this {
            width: 100%;
            height: eval('offsetWidth / (width / height)')px;
          }
        }
      &lt;/style>
    </pre>
  </div>

  In this example the <code>iframe</code> element has a <code>width=""</code> and <code>height=""</code> attribute supplied in HTML which is being accessed from CSS using <code>$it.width</code> and <code>$it.height</code> inside our <a class="property" data-link-type="propdesc" data-lt='eval("")'>eval("")</a> function. Because we are able to compute the HTML attributes directly, this one rule will make multiple <code>iframe</code> elements with <em>different</em> attribute values on the same page responsive, as it computes each iframe separately as <code>$this</code>.
  
<h3 id=faking-input-empty>Faking <code>input:empty</code></h3>

  <div class=example>
    <pre class=language-html>
      &lt;input>
      &lt;style>
        /* input:empty */
        @element 'input' and (max-characters: 0) {
          $this { 
            background: red;
          }
        }
        /* input:not(:empty) */
        @element 'input' and (min-characters: 1) {
          $this { 
            background: lime;
          }
        }
      &lt;/style>
    </pre>
  </div>

  In this example we are able to apply styles based on whether there are zero or at least one characters inside any <code>input</code> element. CSS has the pseudo-class '':empty'', however it doesn't apply to all elements (like <code>input</code> elements) so by using 'max-characters' and 'min-characters' with element queries we are able to express and style a similar idea.

<h3 id=auto-expanding-textarea>Auto-expanding <code>textarea</code></h3>

  <div class=example>
    <pre class=language-html>
      &lt;textarea>&lt;/textarea>
      &lt;style>
        @element 'textarea' {
          $this {
            height: eval("style.height='inherit';style.height=scrollHeight+'px'");
          }
        }
      &lt;/style>
    </pre>
  </div>

  In this example we are using <a class="property" data-link-type="propdesc" data-lt='eval("")'>eval("")</a> to reset the 'height' value of our element and immediately set it to the scrollHeight of the element, ensuring that no matter how many lines of text it contains, it will always expand & contract to contain all of them.

<h3 id=display-browser-dimensions>Display Browser Dimensions</h3>

  <div class=example>
    <pre class=language-html>
      &lt;style>
        @element ':root' {
          $this:before {
            content: 'eval("window.innerWidth") × eval("window.innerHeight")';
            position: fixed;
            top: .5em;
            left: .5em;
          }
        }
      &lt;/style>
    </pre>
  </div>

  This example will create a new pseudo-element on our ':root' element (the HTML element) and uses <a class="property" data-link-type="propdesc" data-lt='eval("")'>eval("")</a> to display the <code>innerWidth</code> and <code>innerHeight</code> values of our <code>window</code>.

<h3 id=self-responsive-grid>Self-responsive Grid</h3>

  <div class=example>
    <pre class=language-html>
      &lt;h2>Responsive Grid&lt;/h2>
      &lt;p>Small = full width, Medium = thirds, Large = sixths.&lt;/p>
      &lt;section data-grid>
        &lt;div class="col-10 medium-split-3 large-split-6">&lt;/div>
        &lt;div class="col-10 medium-split-3 large-split-6">&lt;/div>
        &lt;div class="col-10 medium-split-3 large-split-6">&lt;/div>
        &lt;div class="col-10 medium-split-3 large-split-6">&lt;/div>
        &lt;div class="col-10 medium-split-3 large-split-6">&lt;/div>
        &lt;div class="col-10 medium-split-3 large-split-6">&lt;/div>
      &lt;/section>
      &lt;h2>Split Grid&lt;/h2>
      &lt;p>Small = half width, Medium = 1, 2, 3, 4 split, Large = 4, 3, 2, 1 split.&lt;/p>
      &lt;section data-grid>
        &lt;div class="col-5 medium-split-1 large-split-4">&lt;/div>
        &lt;div class="col-5 medium-split-2 large-split-4">&lt;/div>
        &lt;div class="col-5 medium-split-2 large-split-4">&lt;/div>
        &lt;div class="col-5 medium-split-3 large-split-4">&lt;/div>
        &lt;div class="col-5 medium-split-3 large-split-3">&lt;/div>
        &lt;div class="col-5 medium-split-3 large-split-3">&lt;/div>
        &lt;div class="col-5 medium-split-4 large-split-3">&lt;/div>
        &lt;div class="col-5 medium-split-4 large-split-2">&lt;/div>
        &lt;div class="col-5 medium-split-4 large-split-2">&lt;/div>
        &lt;div class="col-5 medium-split-4 large-split-1">&lt;/div>
      &lt;/section>
      &lt;h2>Hidden Elements&lt;/h2>
      &lt;p>Small = Hide Small, Medium = Hide Medium, Large = Hide Large.&lt;/p>
      &lt;section data-grid>
        &lt;div class="col-10 hide-small">Small&lt;/div>
        &lt;div class="col-10 hide-medium">Medium&lt;/div>
        &lt;div class="col-10 hide-large">Large&lt;/div>
      &lt;/section>
      &lt;style>
        * {
          box-sizing: border-box;
        }
        [data-grid] div {
          min-height: 50px;
          background: lime;
          border: 5px solid white;
        }
        /* Element Query Grid */
        @element '[data-grid]' {
          $this,
          $this * {
            box-sizing: border-box;
          }
          $this:after,
          $this [data-row]:after {
            content: '';
            display: block;
            clear: both;
          }
          $this [class*=-col-],
          $this [class*=-split-] { float: left; }
          $this [class^=col-1] { width: 10%; }
          $this [class^=col-2] { width: 20%; }
          $this [class^=col-3] { width: 30%; }
          $this [class^=col-4] { width: 40%; }
          $this [class^=col-5] { width: 50%; }
          $this [class^=col-6] { width: 60%; }
          $this [class^=col-7] { width: 70%; }
          $this [class^=col-8] { width: 80%; }
          $this [class^=col-9] { width: 90%; }
          $this [class^=col-10] { width: 100%; }
          $this [class^=split-1] { width: calc(100%/1); }
          $this [class^=split-2] { width: calc(100%/2); }
          $this [class^=split-3] { width: calc(100%/3); }
          $this [class^=split-4] { width: calc(100%/4); }
          $this [class^=split-5] { width: calc(100%/5); }
          $this [class^=split-6] { width: calc(100%/6); }
          $this [class^=split-7] { width: calc(100%/7); }
          $this [class^=split-8] { width: calc(100%/8); }
          $this [class^=split-9] { width: calc(100%/9); }
          $this [class^=split-10] { width: calc(100%/10); }
        }
        @element '[data-grid]' and (max-width: 400px) {
          $this [class*=small-col-1] { width: 10%; }
          $this [class*=small-col-2] { width: 20%; }
          $this [class*=small-col-3] { width: 30%; }
          $this [class*=small-col-4] { width: 40%; }
          $this [class*=small-col-5] { width: 50%; }
          $this [class*=small-col-6] { width: 60%; }
          $this [class*=small-col-7] { width: 70%; }
          $this [class*=small-col-8] { width: 80%; }
          $this [class*=small-col-9] { width: 90%; }
          $this [class*=small-col-10] { width: 100%; }
          $this [class*=small-split-1] { width: calc(100%/1); }
          $this [class*=small-split-2] { width: calc(100%/2); }
          $this [class*=small-split-3] { width: calc(100%/3); }
          $this [class*=small-split-4] { width: calc(100%/4); }
          $this [class*=small-split-5] { width: calc(100%/5); }
          $this [class*=small-split-6] { width: calc(100%/6); }
          $this [class*=small-split-7] { width: calc(100%/7); }
          $this [class*=small-split-8] { width: calc(100%/8); }
          $this [class*=small-split-9] { width: calc(100%/9); }
          $this [class*=small-split-10] { width: calc(100%/10); }
          $this [class*=hide-small] { display: none; }
        }
        @element '[data-grid]' and (min-width: 400px) and (max-width: 800px) {
          $this [class*=medium-col-1] { width: 10%; }
          $this [class*=medium-col-2] { width: 20%; }
          $this [class*=medium-col-3] { width: 30%; }
          $this [class*=medium-col-4] { width: 40%; }
          $this [class*=medium-col-5] { width: 50%; }
          $this [class*=medium-col-6] { width: 60%; }
          $this [class*=medium-col-7] { width: 70%; }
          $this [class*=medium-col-8] { width: 80%; }
          $this [class*=medium-col-9] { width: 90%; }
          $this [class*=medium-col-10] { width: 100%; }
          $this [class*=medium-split-1] { width: calc(100%/1); }
          $this [class*=medium-split-2] { width: calc(100%/2); }
          $this [class*=medium-split-3] { width: calc(100%/3); }
          $this [class*=medium-split-4] { width: calc(100%/4); }
          $this [class*=medium-split-5] { width: calc(100%/5); }
          $this [class*=medium-split-6] { width: calc(100%/6); }
          $this [class*=medium-split-7] { width: calc(100%/7); }
          $this [class*=medium-split-8] { width: calc(100%/8); }
          $this [class*=medium-split-9] { width: calc(100%/9); }
          $this [class*=medium-split-10] { width: calc(100%/10); }
          $this [class*=hide-medium] { display: none; }
        }
        @element '[data-grid]' and (min-width: 800px) {
          $this [class*=large-col-1] { width: 10%; }
          $this [class*=large-col-2] { width: 20%; }
          $this [class*=large-col-3] { width: 30%; }
          $this [class*=large-col-4] { width: 40%; }
          $this [class*=large-col-5] { width: 50%; }
          $this [class*=large-col-6] { width: 60%; }
          $this [class*=large-col-7] { width: 70%; }
          $this [class*=large-col-8] { width: 80%; }
          $this [class*=large-col-9] { width: 90%; }
          $this [class*=large-col-10] { width: 100%; }
          $this [class*=large-split-1] { width: calc(100%/1); }
          $this [class*=large-split-2] { width: calc(100%/2); }
          $this [class*=large-split-3] { width: calc(100%/3); }
          $this [class*=large-split-4] { width: calc(100%/4); }
          $this [class*=large-split-5] { width: calc(100%/5); }
          $this [class*=large-split-6] { width: calc(100%/6); }
          $this [class*=large-split-7] { width: calc(100%/7); }
          $this [class*=large-split-8] { width: calc(100%/8); }
          $this [class*=large-split-9] { width: calc(100%/9); }
          $this [class*=large-split-10] { width: calc(100%/10); }
          $this [class*=hide-large] { display: none; }
        }
      &lt;/style>
    </pre>
  </div>

  This example uses ''@element'' queries to apply the different responsive styles to our grid when the grid element itself reaches certain breakpoints. Because the styles are scoped to each grid using <a class="property" data-link-type="propdesc" data-lt="$this" for=meta-selectors>$this</a>, we can use these same styles to power many grids in the same layout all using the same styles.